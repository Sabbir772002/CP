{
    "2dpref": {
        "prefix": "2dpref",
        "body": [
            "const int N = 1005;",
            "int a[N][N], pref[N][N];",
            "",
            "  int n, m; cin >> n >> m;",
            "  for (int i = 1; i <= n; i++) {",
            "    for (int j = 1; j <= m; j++) {",
            "      cin >> a[i][j];",
            "    }",
            "  }",
            "  for (int i = 1; i <= n; i++) {",
            "    for (int j = 1; j <= m; j++) {",
            "      pref[i][j] = pref[i - 1][j] + pref[i][j - 1] - pref[i - 1][j - 1] + a[i][j];",
            "    }",
            "  }",
            "  int q; cin >> q;",
            "  while (q--) {",
            "    int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;",
            "    int ans = 0;",
            "    // for (int i = x1; i <= x2; i++) {",
            "    //   for (int j = y1; j <= y2; j++) {",
            "    //     ans += a[i][j];",
            "    //   }",
            "    // }",
            "    ans = pref[x2][y2] - pref[x1 - 1][y2] - pref[x2][y1 - 1] + pref[x1 - 1][y1 - 1];",
            "    cout << ans << '\\n';",
            "  }"
        ],
        "description": "2dpref"
    },
    "aa": {
        "prefix": "aa",
        "body": [
            "vector<int> vv(n);",
            "for(int i=0;i<n;i++){",
            "\tcin>>vv[i];",
            "}"
        ],
        "description": "Create an if statement to check if f == 1 and print YES/NO"
    },
    "ab": {
        "prefix": "ab",
        "body": [
            "vector<int> b(n);",
            "for(int i=0;i<n;i++){",
            "\tcin>>b[i];",
            "}"
        ],
        "description": ""
    },
    "ac": {
        "prefix": "ac",
        "body": [
            "vector<int> c(n);",
            "for(int i=0;i<n;i++){",
            "    cin>>c[i];",
            "}"
        ],
        "description": ""
    },
    "ad": {
        "prefix": "ad",
        "body": [
            "vector<int> d(n);",
            "for(int i=0;i<n;i++){",
            "    cin>>d[i];",
            "}"
        ],
        "description": ""
    },
    "bfor": {
        "prefix": "bfor",
        "body": [
            "for(int i=n-1;i>=0;i--){",
            "    ${1:}",
            "}"
        ],
        "description": "print YES"
    },
    "bfs": {
        "prefix": "bfs",
        "body": [
            "queue<int> q;",
            "  vector<int> d(n + 1, inf), par(n + 1, -1);",
            "  q.push(1);",
            "  d[1] = 0;",
            "  while (!q.empty()) {",
            "    int u = q.front();",
            "    q.pop();",
            "    for (auto v: g[u]) {",
            "      if (d[u] + 1 < d[v]) {",
            "        d[v] = d[u] + 1;",
            "        par[v] = u;",
            "        q.push(v);",
            "      }",
            "    }",
            "}"
        ],
        "description": "bfs"
    },
    "binexp": {
        "prefix": "binexp",
        "body": [
            "//fast_expo + MOD",
            "",
            "ll ipowM(ll base ,ll exp,ll MOD){",
            "    ll res = 1;",
            "    while(exp>0){",
            "        if(exp&1) res = (res*base)%MOD;",
            "        exp>>=1;",
            "        base = (base*base)%MOD;",
            "    }",
            "return res;",
            "}",
            "",
            "//simple power",
            "ll ipow(ll base ,ll exp){",
            "    ll res = 1;",
            "    while(exp>0){",
            "        if(exp&1) res = (res*base);",
            "        exp>>=1;",
            "        base = (base*base);",
            "    }",
            "return res;",
            "}"
        ],
        "description": "binexp"
    },
    "bit": {
        "prefix": "bit",
        "body": [
            "int bit[3*(int)3e5+8]={0};",
            "int n;",
            "void add(int idx) {",
            "    for (++idx; idx < n; idx += idx & -idx)",
            "        bit[idx] +=1;",
            "}",
            "void range(int l, int r, int val) {",
            "    // add(l, val);",
            "    // add(r + 1, -val);",
            "}",
            "",
            "int point(int idx) {",
            "    int ret = 0;",
            "    for (++idx; idx > 0; idx -= idx & -idx)",
            "        ret += bit[idx];",
            "    return ret;",
            "}"
        ],
        "description": "Create an if statement to check if f == 1 and print YES/NO"
    },
    "dp": {
        "prefix": "dp",
        "body": [
            "int dp[(int)1e5+100];",
            "int v[(int)1e5+100];",
            "",
            "ll find(int i,ll sum,ll n,ll m){",
            "  if(i==n){",
            "    return (sum>0 and sum<=m);",
            "  }",
            "  ll &ret=dp[i];",
            "  if(ret!=-1)return dp[i];",
            "  int ans=0;",
            "  ans=find(i+1,sum,n,m);",
            "  ans=max(1+find(i+1,v[i]+sum,n,m),ans);",
            "  return dp[i]=ans;",
            "",
            "}"
        ],
        "description": "Create an if statement to check if f == 1 and print YES/NO"
    },
    "bg": {
        "prefix": "bg",
        "body": [
            "#ifdef Sabbir",
            "#include <E:\\CodeBox\\TempBox\\Debug\\dbg.h>",
            "#else",
            "#define dbg(x...)",
            "#endif"
        ],
        "description": "Inline Bug"
    },
    "bug2": {
        "prefix": "bug2",
        "body": [
            "#ifdef Sabbir",
            "template <typename T>",
            "istream &operator>>(istream &in, vector<T> &a){",
            "  for (auto &x:a)in>>x;",
            "    return in;",
            "};",
            "template <typename T>",
            "ostream &operator<<(ostream &out, vector<T> &a){",
            "  for (auto &x:a)out<<x<<\" \";",
            "    return out;",
            "};",
            "",
            "#define dbg(...) __f(#__VA_ARGS__, __VA_ARGS__)",
            "template <typename Arg1>",
            "void __f(const char *name, Arg1 &&arg1) {",
            "    cerr << name << \" = \" << arg1 << std::endl;",
            "}",
            "template <typename Arg1, typename... Args>",
            "void __f(const char *names, Arg1 &&arg1, Args &&...args) {",
            "    const char *comma = strchr(names + 1, ',');",
            "    cerr.write(names, comma - names) << \" = \" << arg1 << \" | \";",
            "    __f(comma + 1, args...);",
            "}",
            "#else",
            "#define dbg(...)",
            "#endif"
        ],
        "description": "bug2"
    },
    "combi": {
        "prefix": "combi",
        "body": [
            "//combi",
            "const long long int x = 100 ;",
            "ll fact[x+1];",
            "ll ifact[x+1];",
            "void prefact(ll MOD){",
            "    fact[0]=1;",
            "    ifact[0]=1;",
            "    for(ll i = 1 ;i<=x ;i++){",
            "        fact[i] = (fact[i-1]*i)%MOD;",
            "        ifact[i] = (ifact[i-1]*invM(i,MOD))%MOD;",
            "    }",
            "}",
            "ll add(ll a,ll b){",
            "    return (a+b+MOD)%MOD;",
            "}",
            "ll mul(ll a,ll b){",
            "    return (a*1LL*b)%MOD;",
            "}",
            "ll ncr(ll n,ll k){",
            "    if(k>n)",
            "        return 0;",
            "    return mul(fact[n],mul(ifact[n-k],ifact[k]))%MOD;",
            "}"
        ],
        "description": "combi"
    },
    "combiadv": {
        "prefix": "combiadv",
        "body": [
            "int nCrDigits(int n, int r)",
            "{",
            "    if(n==r||r==0)",
            "        return 1;",
            "    if(r>n)",
            "        return 0;",
            "    if(n<0)",
            "        return 0;",
            "    int ans=(fact[n]*ifact[n-r])%MOD;",
            "    ans=(ans*ifact[r])%MOD;",
            "    return ans;",
            "}   ",
            "",
            "ll ncrL(ll n,ll r){",
            "    if(r==0||n==r)",
            "     return 1;",
            "    if(r>n)",
            "        return 0;     ",
            "    if(n<0)",
            "        return 0;        ",
            "   int dig_n = n%MOD;",
            "   int dig_r = r%MOD; ",
            "  return (nCrDigits(dig_n,dig_r) * ncrL(n/MOD, r/MOD))%MOD;",
            "}"
        ],
        "description": "combiadv"
    },
    "contest": {
        "prefix": "contest",
        "body": [
            "//Author : Krishan Kant Agnihotri        ",
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "",
            "//ordered_set",
            "template<class T> using oset =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;",
            "#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>",
            "",
            "//find_by_order(k)  returns iterator to kth element starting from 0;",
            "//order_of_key(k) returns count of elements strictly smaller than k;",
            "//erase,insert same as normal set",
            "//define it as oset<int> s; or oset<pair<int,int>> s;",
            "",
            "//bunch of pragmas",
            "#pragma GCC optimize(\"O3\")",
            "#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")",
            "#pragma comment(linker, \"/stack:200000000\")",
            "#pragma GCC target(\"sse,sse2,sse3,sse4,popcnt,abm,mmx,tune=native\")",
            "",
            "",
            "//#pragma Gcc target(\"avx2,fma,avx\")",
            "//(Uncomment when needed and be sure it not give TLE bcoz it requires time)",
            "//#pragma GCC optimize \"trapv\"//to check integer overflow and gives RE.",
            "",
            "//macros",
            "#define ull unsigned long long int",
            "#define ll long long",
            "#define ii pair<int,int>",
            "#define vii vector<ii>",
            "#define vi vector<int>",
            "#define vl vector<ll>",
            "#define mii map<int,int>",
            "#define uii unordered_map<int,int>",
            "#define all(x) x.begin(),x.end()",
            "#define ff first",
            "#define fr(i,a,b) for(int i= a ;i<=b ;i++)",
            "#define ss second",
            "#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);",
            "#define endl \"\\n\"",
            "#define pb push_back",
            "#define INF 1e18",
            "#define lcm(a,b) a*b/__gcd(a,b)",
            "#define print(x) cout<<x<<\"\\n\";",
            "#define scanv(v,n) for(int i  = 0 ; i<n ;i++ ) cin>>v[i];",
            "#define printv(v) for(auto it : v) cout<<it<<\" \";",
            "#define rall(v) v.rbegin(),v.rend()",
            "#define GOOGLE(i) cout<<\"Case\"<<\" #\"<<i<<\": \";",
            "#define Time cerr<<\"\\nTime Taken : \"<<(float)(clock()-time_p)/CLOCKS_PER_SEC<<\"\\n\";",
            "clock_t time_p=clock();",
            "",
            "//boost for big int ",
            "//#include<boost/multiprecision/cpp_int.hpp>",
            "//uncoment for large int requirement",
            "//using boost::multiprecision::cpp_int;",
            "",
            "//forced_functions ",
            "void file_io(){",
            "fast_io",
            "    #ifndef ONLINE_JUDGE",
            "    freopen(\"inputa.txt\",\"r\",stdin);",
            "    freopen(\"outputa.txt\",\"w\",stdout);",
            "    freopen(\"log.txt\",\"w\",stderr);",
            "    #endif",
            "}",
            "",
            "//safe_hash",
            "struct custom_hash {",
            "    static uint64_t splitmix64(uint64_t x) {",
            "        // http://xorshift.di.unimi.it/splitmix64.c",
            "        x += 0x9e3779b97f4a7c15;",
            "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "        return x ^ (x >> 31);",
            "    }",
            "",
            "    size_t operator()(uint64_t x) const {",
            "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
            "        return splitmix64(x + FIXED_RANDOM);",
            "    }",
            "};",
            "//use it with unordered_map<T,T,custom_hash> safe_map",
            "",
            "//const",
            "const long long int MOD = 1e9+7;",
            "const long long int MOD2 = (119<<23)+1;//(119<<23)+1==998244353",
            "//random",
            "ll stoii(string s){",
            "    ll ans = 0;",
            "    for(auto it: s){",
            "        ll cur = it-'0';",
            "        ans = ans*10+cur;",
            "    }",
            "    return ans;",
            "}",
            "",
            "//matrix stuff",
            "int dx[]={-1,0,1,0};",
            "int dy[]={0,1,0,-1};",
            "",
            "bool test = true;",
            "bool file = true;",
            "void solve(){",
            "",
            "}",
            "int main(){",
            "    if(file)",
            "      file_io();",
            "    int t ;",
            "    t = 1 ;",
            "    if(test)",
            "    cin>>t;",
            "    while(t--){",
            "            solve();",
            "",
            "    }",
            "    Time",
            "}"
        ],
        "description": "contest"
    },
    "cpp": {
        "prefix": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "#define ull unsigned long long int",
            "#define ll long long",
            "#define ii pair<int,int>",
            "#define vii vector<ii>",
            "#define vi vector<int>",
            "#define vl vector<ll>",
            "#define mii map<int,int>",
            "#define uii unordered_map<int,int>",
            "#define all(x) x.begin(),x.end()",
            "#define ff first",
            "#define fr(i,a,b) for(int i= a ;i<=b ;i++)",
            "#define ss second",
            "#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);",
            "#define endl \"\\n\"",
            "#define pb push_back",
            "#define INF 1e18",
            "#define lcm(a,b) a*b/__gcd(a,b)",
            "#define print(x) cout<<x<<\"\\n\";",
            "#define scanv(v,n) for(int i  = 0 ; i<n ;i++ ) cin>>v[i];",
            "#define printv(v) for(auto it : v) cout<<it<<\" \";",
            "#define rall(v) v.rbegin(),v.rend()",
            "#define GOOGLE(i) cout<<\"Case\"<<\" #\"<<i<<\": \";",
            "#define Time cerr<<\"\\nTime Taken : \"<<(float)(clock()-time_p)/CLOCKS_PER_SEC<<\"\\n\";",
            "clock_t time_p=clock();",
            "",
            "int main()",
            "{",
            "   #ifndef ONLINE_JUDGE",
            "    freopen(\"inputa.txt\",\"r\",stdin);",
            "    freopen(\"outputa.txt\",\"w\",stdout);",
            "    freopen(\"log.txt\",\"w\",stderr);",
            "    #endif",
            "int t;",
            "t = 1;",
            "cin>>t;",
            "while(t--){",
            "",
            "}",
            "Time",
            "}"
        ],
        "description": "my cpp template"
    },
    "bug": {
        "prefix": "bug",
        "body": [
            "#ifdef Sabbir",
            "#include <E:\\CodeBox\\TempBox\\Debug\\debug.h>",
            "#else",
            "#define dbg(x...)",
            "#endif"
        ],
        "description": "Create an if statement to check if f == 1 and print YES/NO"
    },
    "dfs": {
        "prefix": "dfs",
        "body": [
            "const int N = 1e5 + 9;",
            "vector<int> g[N];",
            "bool vis[N];",
            "void dfs(int u) {",
            "  vis[u] = true;",
            "  for (auto v: g[u]) {",
            "    if (!vis[v]) {",
            "      dfs(v);",
            "    }",
            "  }",
            "}"
        ],
        "description": "dfs"
    },
    "diameter": {
        "prefix": "diameter",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "const int N = 2e5 + 9;",
            "",
            "vector<int> g[N];",
            "int farthest(int s, int n, vector<int> &d) {",
            "  static const int inf = N;",
            "  d.assign(n + 1, inf); d[s] = 0;",
            "  vector<bool> vis(n + 1);",
            "  queue<int> q; q.push(s);",
            "  vis[s] = 1; int last = s;",
            "  while (!q.empty()) {",
            "    int u = q.front(); q.pop();",
            "    for (int v: g[u]) {",
            "      if (vis[v]) continue;",
            "      d[v] = d[u] + 1;",
            "      q.push(v); vis[v] = 1;",
            "    }",
            "    last = u;",
            "  }",
            "  return last;",
            "}",
            "int32_t main() {",
            "  ios_base::sync_with_stdio(0);",
            "  cin.tie(0);",
            "  int n; cin >> n;",
            "  for (int i = 1; i < n; i++) {",
            "    int u, v; cin >> u >> v;",
            "    g[u].push_back(v);",
            "    g[v].push_back(u);",
            "  }",
            "  vector<int> dx, dy;",
            "  int x = farthest(1, n, dx);",
            "  int y = farthest(x, n, dx);",
            "  farthest(y, n, dy);",
            "  for (int i = 1; i <= n; i++) {",
            "    cout << max(dx[i], dy[i]) << ' ';",
            "  }",
            "  cout << '\\n';",
            "  return 0;",
            "}"
        ],
        "description": "diameter"
    },
    "dsu-kk": {
        "prefix": "dsu-kk",
        "body": [
            "vector<ll> rnk(N+1,0);",
            "vector<ll> par(N,0);",
            "vector<ll> mx(N,INT_MIN);",
            "vector<ll> mn(N,INT_MAX);",
            "vector<ll> sz(N,1);",
            "ll find(ll a){",
            "    if(par[a]==a)",
            "        return par[a];",
            "    return par[a] = find(par[a]);",
            "}",
            "ll merge(ll a,ll b){",
            "\t//merge smaller into bigger",
            "\ta= fnd(a);",
            "\tb= fnd(b);",
            "\tif(sz[a]>sz[b])",
            "\t    swap(a,b);",
            "\tpar[a]=b;",
            "\tmn[b]=min(mn[a],mn[b]);",
            "\tmx[b]=max(mx[a],mx[b]);",
            "\tif(a!=b)",
            "\t    sz[b]+=sz[a];",
            "",
            "",
            "}",
            "int same(ll a,ll b){",
            "\tll x=find(a);",
            "\tll y=find(b);",
            "\tif(x==y)return 1;",
            "\telse return 0;",
            "}"
        ],
        "description": "dsu-kk"
    },
    "dsu": {
        "prefix": "dsu",
        "body": [
            "// Implement (union by size) + (path compression)",
            "// Reference:",
            "// Zvi Galil and Giuseppe F. Italiano,",
            "// Data structures and algorithms for disjoint set union problems",
            "struct dsu {",
            "  public:",
            "    dsu() : _n(0) {}",
            "    dsu(int n) : _n(n), parent_or_size(n, -1) {}",
            "",
            "    int merge(int a, int b) {",
            "        assert(0 <= a && a < _n);",
            "        assert(0 <= b && b < _n);",
            "        int x = leader(a), y = leader(b);",
            "        if (x == y) return x;",
            "        if (-parent_or_size[x] < -parent_or_size[y]) swap(x, y);",
            "        parent_or_size[x] += parent_or_size[y];",
            "        parent_or_size[y] = x;",
            "        return x;",
            "    }",
            "",
            "    bool same(int a, int b) {",
            "        assert(0 <= a && a < _n);",
            "        assert(0 <= b && b < _n);",
            "        return leader(a) == leader(b);",
            "    }",
            "",
            "    int leader(int a) {",
            "        assert(0 <= a && a < _n);",
            "        if (parent_or_size[a] < 0) return a;",
            "        return parent_or_size[a] = leader(parent_or_size[a]);",
            "    }",
            "",
            "    int size(int a) {",
            "        assert(0 <= a && a < _n);",
            "        return -parent_or_size[leader(a)];",
            "    }",
            "",
            "    vector<vector<int>> groups() {",
            "        vector<int> leader_buf(_n), group_size(_n);",
            "        for (int i = 0; i < _n; i++) {",
            "            leader_buf[i] = leader(i);",
            "            group_size[leader_buf[i]]++;",
            "        }",
            "        vector<vector<int>> result(_n);",
            "        for (int i = 0; i < _n; i++) {",
            "            result[i].reserve(group_size[i]);",
            "        }",
            "        for (int i = 0; i < _n; i++) {",
            "            result[leader_buf[i]].push_back(i);",
            "        }",
            "        result.erase(",
            "            remove_if(result.begin(), result.end(),",
            "                           [&](const vector<int>& v) { return v.empty(); }),",
            "            result.end());",
            "        return result;",
            "    }",
            "",
            "  private:",
            "    int _n;",
            "    // root node: -1 * component size",
            "    // otherwise: parent",
            "vector<int> parent_or_size;",
            "};"
        ],
        "description": "dsu"
    },
    "fenwick": {
        "prefix": "fenwick",
        "body": [
            "template <class T> struct fenwick_tree {",
            "    using U = T;",
            "",
            "  public:",
            "    fenwick_tree() : _n(0) {}",
            "    fenwick_tree(int n) : _n(n), data(n) {}",
            "",
            "    void add(int p, T x) {",
            "        assert(0 <= p && p < _n);",
            "        p++;",
            "        while (p <= _n) {",
            "            data[p - 1] += U(x);",
            "            p += p & -p;",
            "        }",
            "    }",
            "",
            "    T sum(int l, int r) {",
            "        assert(0 <= l && l <= r && r <= _n);",
            "        return sum(r) - sum(l);",
            "    }",
            "",
            "  private:",
            "    int _n;",
            "    vector<U> data;",
            "",
            "    U sum(int r) {",
            "        U s = 0;",
            "        while (r > 0) {",
            "            s += data[r - 1];",
            "            r -= r & -r;",
            "        }",
            "        return s;",
            "    }",
            "};",
            "",
            "}"
        ],
        "description": "fenwick"
    },
    "file": {
        "prefix": "file",
        "body": [
            "void file_io(){",
            "     fast_io",
            "    #ifndef ONLINE_JUDGE",
            "    freopen(\"inputa.txt\",\"r\",stdin);",
            "    freopen(\"outputa.txt\",\"w\",stdout);",
            "    freopen(\"log.txt\",\"w\",stderr);",
            "    #endif",
            "}"
        ],
        "description": "file"
    },
    "fr": {
        "prefix": "fr",
        "body": [
            "for(int i=0;i<n;i++){",
            "   ${0}",
            "}"
        ],
        "description": ""
    },
    "frr": {
        "prefix": "frr",
        "body": [
            "frr(int i=n-1;i>=0;i--){",
            "    ${0}",
            "}"
        ],
        "description": ""
    },
    "hashbig": {
        "prefix": "hashbig",
        "body": [
            "struct custom_hash {",
            "    static uint64_t splitmix64(uint64_t x) {",
            "        x += 0x9e3779b97f4a7c15;",
            "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "        return x ^ (x >> 31);",
            "    }",
            " ",
            "    size_t operator()(uint64_t x) const {",
            "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
            "        return splitmix64(x + FIXED_RANDOM);",
            "    }",
            "}rng;"
        ],
        "description": "hashbig"
    },
    "ifdbg": {
        "prefix": "ifdbg",
        "body": [
            "#ifdef Sabbir",
            "    freopen(\"Error.txt\", \"w\", stderr);",
            "#endif"
        ],
        "description": "print YES"
    },
    "iff": {
        "prefix": "iff",
        "body": [
            "if (${1:f} == 1) {",
            "    cout << \"YES\" << endl;",
            "} else {",
            "    cout << \"NO\" << endl;",
            "}"
        ],
        "description": "Create an if statement to check if f == 1 and print YES/NO"
    },
    "in": {
        "prefix": "in",
        "body": [
            "template <typename T>",
            "istream &operator>>(istream &in, vector<T> &a){",
            "  for (auto &x:a)in>>x;",
            "    return in;",
            "};",
            "template <typename T>",
            "ostream &operator<<(ostream &out, vector<T> &a){",
            "  for (auto &x:a)out<<x<<\" \";",
            "    return out;",
            "};"
        ],
        "description": "in"
    },
    "inf": {
        "prefix": "inf",
        "body": [
            "const ll inf=1e9;"
        ],
        "description": "infinity"
    },
    "suff": {
        "prefix": "suff",
        "body": [
            "vector<long long> suff(n+2);",
            "for(int i=n-1;i>=0;i--){",
            "    if(i==n-1){",
            "        suff[i]=v[i];",
            "    }else{",
            "        suff[i]=suff[i+1]+v[i];",
            "    }",
            "}"
        ],
        "description": "Create an if statement to check if f == 1 and print YES/NO"
    },
    "inversemod": {
        "prefix": "inversemod",
        "body": [
            "//fast_expo + MOD",
            "",
            "ll ipowM(ll base ,ll exp,ll MOD){",
            "    ll res = 1;",
            "    while(exp>0){",
            "        if(exp&1) res = (res*base)%MOD;",
            "        exp>>=1;",
            "        base = (base*base)%MOD;",
            "    }",
            "return res;",
            "}",
            "//INVERSE ",
            "ll invM(ll num ,ll m){",
            "    return ipowM(num,m-2,m);",
            "}"
        ],
        "description": "inversemod"
    },
    "kmp": {
        "prefix": "kmp",
        "body": [
            "string s1, s2, s3;",
            "int F[mx];",
            " ",
            "int kmp(string ss, string p) {",
            "    string s = p + \"#\" + ss;",
            "    F[0] = 0;",
            "    for (int i = 1; i < s.size(); i++) {",
            "        int j = F[i - 1];",
            "        while (j > 0 && s[j] != s[i]) j = F[j - 1];",
            "        if (s[i] == s[j]) j++;",
            "        F[i] = j;",
            "        if (F[i] == p.size()) return 1;",
            "        //return ss if string need",
            "        //if (F[i] == p.size()) return ss;",
            "",
            "    }",
            "   //containing two p and ss as substring",
            "   // int mat = F[s.size() - 1];",
            "    //for (int i = mat; i < a.size(); i++) b += a[i]; ",
            "    return 0;",
            "}"
        ],
        "description": "kmp"
    },
    "kk": {
        "prefix": "kk",
        "body": [],
        "description": "kk"
    },
    "lca": {
        "prefix": "lca",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "const int N = 3e5 + 9, LG = 18;",
            "",
            "vector<int> g[N];",
            "int par[N][LG + 1], dep[N], sz[N];",
            "void dfs(int u, int p = 0) {",
            "  par[u][0] = p;",
            "  dep[u] = dep[p] + 1;",
            "  sz[u] = 1;",
            "  for (int i = 1; i <= LG; i++) par[u][i] = par[par[u][i - 1]][i - 1];",
            "  for (auto v: g[u]) if (v != p) {",
            "    dfs(v, u);",
            "    sz[u] += sz[v];",
            "  }",
            "}",
            "int lca(int u, int v) {",
            "  if (dep[u] < dep[v]) swap(u, v);",
            "  for (int k = LG; k >= 0; k--) if (dep[par[u][k]] >= dep[v]) u = par[u][k];",
            "  if (u == v) return u;",
            "  for (int k = LG; k >= 0; k--) if (par[u][k] != par[v][k]) u = par[u][k], v = par[v][k];",
            "  return par[u][0];",
            "}",
            "int kth(int u, int k) {",
            "  assert(k >= 0);",
            "  for (int i = 0; i <= LG; i++) if (k & (1 << i)) u = par[u][i];",
            "  return u;",
            "}",
            "int dist(int u, int v) {",
            "  int l = lca(u, v);",
            "  return dep[u] + dep[v] - (dep[l] << 1);",
            "}",
            "//kth node from u to v, 0th node is u",
            "int go(int u, int v, int k) {",
            "  int l = lca(u, v);",
            "  int d = dep[u] + dep[v] - (dep[l] << 1);",
            "  assert(k <= d);",
            "  if (dep[l] + k <= dep[u]) return kth(u, k);",
            "  k -= dep[u] - dep[l];",
            "  return kth(v, dep[v] - dep[l] - k);",
            "}",
            "int32_t main() {",
            "  int n; cin >> n;",
            "  for (int i = 1; i < n; i++) {",
            "    int u, v; cin >> u >> v;",
            "    g[u].push_back(v);",
            "    g[v].push_back(u);",
            "  }",
            "  dfs(1);",
            "  int q; cin >> q;",
            "  while (q--) {",
            "    int u, v; cin >> u >> v;",
            "    cout << dist(u, v) << '\\n';",
            "  }",
            "  return 0;",
            "}"
        ],
        "description": "lca"
    },
    "linearsieve": {
        "prefix": "linearsieve",
        "body": [
            "const ll mx = 1e7+1 ; ",
            "vector<int> prime;",
            "int lps[mx];",
            "void linear_sieve(){",
            "",
            "memset(lps,0,sizeof(lps));",
            "for(int i = 2 ;i<mx;i++){",
            "\tif(lps[i]==0){",
            "\t\tprime.pb(i);",
            "\t\tlps[i] = i ; ",
            "\t}",
            "\tfor(int j = 0 ;(j<prime.size())&&(lps[i]>=prime[j])&&((i*prime[j]<mx)) ; j++)",
            "\t\tlps[prime[j]*i] = prime[j];",
            "}",
            "",
            "}"
        ],
        "description": "linearsieve"
    },
    "lis_bin": {
        "prefix": "lis_bin",
        "body": [
            "vector<int> lis(const vector<int> &a)",
            "{",
            "    vector<int> L(a.size());",
            "    vector<int> Lis(a.size());",
            "    int lisCount = 0;",
            "    for (int i = 0; i < a.size(); ++i)",
            "    {",
            "        int pos = lower_bound(L.begin(), L.begin() + lisCount, a[i])",
            "                     - L.begin();",
            "        L[pos] = a[i];",
            "        if (pos == lisCount)",
            "            ++lisCount;",
            "        Lis[i] = pos + 1;",
            "    }",
            "    // for(int i=0;i<a.size();i++){",
            "    //     cout<<Lis[i]<<\" \";",
            "    // }",
            "    return Lis;",
            "}"
        ],
        "description": "lis_bin"
    },
    "matrixmul": {
        "prefix": "matrixmul",
        "body": [
            "// #include <bits/stdc++.h>",
            "// #define endl \"\\n\"",
            "// #define ll long long",
            "#define MAX 101",
            "#define MOD 1000000007",
            "using namespace std;",
            "int a[MAX][MAX];int I[MAX][MAX];",
            "void mul(int a[MAX][MAX], int I[MAX][MAX],int n)",
            "{",
            "",
            "    int res[n][n];",
            "    for(int i = 0 ; i<n ; i++)",
            "        for(int j = 0 ; j<n ;j++)",
            "    {",
            "",
            "        res[i][j]=0;",
            "        for(int k = 0 ;k<n ;k++)",
            "            res[i][j]=(res[i][j]%MOD+(a[i][k]*I[k][j])%MOD)%MOD;}",
            "        for(int i = 0 ; i<n ;i++)",
            "            for(int j = 0 ; j<n ;j++)",
            "            a[i][j]=res[i][j];",
            "",
            "}",
            "void powM(int a[MAX][MAX],int n , int p)",
            "{ int I[MAX][MAX];",
            "for(int i = 0 ; i<n ; i++)",
            "    for(int j = 0 ; j<n; j++)",
            "    {if(i==j)",
            "    I[i][j]=1;",
            "    else",
            "    I[i][j]=0;}",
            "  while(p)",
            "  {",
            "      if(p%2!=0)",
            "      {mul(I,a,n);",
            "      p--;",
            "      }else",
            "      {",
            "      mul(a,a,n);",
            "      p>>=1;}",
            "",
            "  }",
            "    for(int i = 0  ; i<n; i++)",
            "        for(int j = 0 ; j<n ;j++)",
            "        a[i][j]=I[i][j];",
            "}",
            "void print(int a[][101],int n)",
            "{",
            "for(int i = 0 ; i<n ;i++)",
            "{        for(int j = 0 ; j<n ; j++)",
            "        cout<<a[i][j]<<\" \";",
            "cout<<endl;",
            "}",
            "}",
            "// int main()",
            "// {ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);",
            "//     int t;",
            "//     cin>>t;",
            "//     while(t--)",
            "//     {int dim,n;//dimension of matrix and n is the power of matrix",
            "//     cin>>dim>>n;",
            "//     //int mat[dim][dim];",
            "//     for(int i = 0 ; i<dim ;i++)",
            "//         for(int j = 0 ; j<dim ;j++)",
            "//         cin>>a[i][j];",
            "//     powM(a,dim,n);",
            "//     print(a,dim);",
            "//     }",
            "// }"
        ],
        "description": "matrixmul"
    },
    "me": {
        "prefix": "me",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "",
            "template<class T> using oset =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;",
            "#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>",
            "",
            "//find_by_order(k)  returns iterator to kth element starting from 0;",
            "//order_of_key(k) returns count of elements strictly smaller than k;",
            "//erase,insert same as normal set",
            "//define it as oset<int> s; or oset<pair<int,int>> s;",
            "",
            "#pragma GCC optimize(\"O3\")",
            "#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")",
            "#pragma comment(linker, \"/stack:200000000\")",
            "#pragma GCC target(\"sse,sse2,sse3,sse4,popcnt,abm,mmx,tune=native\")",
            "",
            "",
            "//#pragma Gcc target(\"avx2,fma,avx\")",
            "//(Uncomment when needed and be sure it not give TLE bcoz it requires time)",
            "//#pragma GCC optimize \"trapv\"//to check integer overflow and gives RE.",
            "",
            "#define ull unsigned long long int",
            "#define ll long long",
            "#define ii pair<int,int>",
            "#define vii vector<ii>",
            "#define vi vector<int>",
            "#define vl vector<ll>",
            "#define mii map<int,int>",
            "#define uii unordered_map<int,int>",
            "#define all(x) x.begin(),x.end()",
            "#define ff first",
            "#define fr(i,a,b) for(int i= a ;i<=b ;i++)",
            "#define ss second",
            "#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);",
            "#define endl \"\\n\"",
            "#define pb push_back",
            "#define INF 1e18",
            "#define lcm(a,b) a*b/__gcd(a,b)",
            "#define print(x) cout<<x<<\"\\n\";",
            "#define scanv(v,n) for(int i  = 0 ; i<n ;i++ ) cin>>v[i];",
            "#define printv(v) for(auto it : v) cout<<it<<\" \";",
            "#define rall(v) v.rbegin(),v.rend()",
            "#define GOOGLE(i) cout<<\"Case\"<<\" #\"<<i<<\": \";",
            "#define Time cerr<<\"\\nTime Taken : \"<<(float)(clock()-time_p)/CLOCKS_PER_SEC<<\"\\n\";",
            "clock_t time_p=clock();",
            "",
            "",
            "//#include<boost/multiprecision/cpp_int.hpp>",
            "//uncoment for large int requirement",
            "//using boost::multiprecision::cpp_int;",
            "void file_io(){",
            "fast_io",
            "    #ifndef ONLINE_JUDGE",
            "    freopen(\"inputa.txt\",\"r\",stdin);",
            "    freopen(\"outputa.txt\",\"w\",stdout);",
            "    freopen(\"log.txt\",\"w\",stderr);",
            "    #endif",
            "}",
            "struct custom_hash {",
            "    static uint64_t splitmix64(uint64_t x) {",
            "        // http://xorshift.di.unimi.it/splitmix64.c",
            "        x += 0x9e3779b97f4a7c15;",
            "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "        return x ^ (x >> 31);",
            "    }",
            "",
            "    size_t operator()(uint64_t x) const {",
            "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
            "        return splitmix64(x + FIXED_RANDOM);",
            "    }",
            "};",
            "//use it with unordered_map<T,T,custom_hash> safe_map",
            "const long long int MOD = 1e9+7;",
            "const long long int MOD2 = (119<<23)+1;//(119<<23)+1==998244353",
            "template<typename T>",
            "struct FenwickTree",
            "{",
            "    T N;",
            "    vector<int> tree;",
            "",
            "    void init(int n)",
            "    {",
            "        N = n;",
            "        tree.assign(n + 1, 0);",
            "    }",
            "",
            "    void update(int idx, T val)",
            "    {",
            "        while (idx <= N)",
            "        {",
            "            tree[idx] += val;",
            "            idx += idx & -idx;",
            "        }",
            "    }",
            "",
            "    void updateMax(int idx, T val)",
            "    {",
            "        while (idx <= N)",
            "        {",
            "            tree[idx] = max(tree[idx], val);",
            "            idx += idx & -idx;",
            "        }",
            "    }",
            "",
            "    T pref(int idx)",
            "    {",
            "        T ans = 0;",
            "        while (idx > 0)",
            "        {",
            "            ans += tree[idx];",
            "            idx -= idx & -idx;",
            "        }",
            "        return ans;",
            "    }",
            "",
            "    T rsum(int l, int r)",
            "    {",
            "        return pref(r) - pref(l - 1);",
            "    }",
            "",
            "    T prefMax(int idx)",
            "    {",
            "        T ans = -2e9;",
            "        while (idx > 0)",
            "        {",
            "            ans = max(ans, tree[idx]);",
            "            idx -= idx & -idx;",
            "        }",
            "        return ans;",
            "    }",
            "};",
            "",
            "struct SegTree {",
            "    typedef int T;",
            "    static constexpr T unit = 0;",
            "    T f(T a, T b) { return a+b; } // (any associative fn)",
            "    vector<T> s; int n;",
            "    SegTree(int _n = 0, T def = unit) : s(2*_n, def), n(_n) {}",
            "    void update(int pos, T val) {",
            "        for (s[pos += n] = val; pos /= 2;)",
            "            s[pos] = f(s[pos * 2], s[pos * 2 + 1]);",
            "    }",
            "    T query(int b, int e) { // query [b, e)",
            "        T ra = unit, rb = unit;",
            "        for (b += n, e += n; b < e; b /= 2, e /= 2) {",
            "            if (b % 2) ra = f(ra, s[b++]);",
            "            if (e % 2) rb = f(s[--e], rb);",
            "        }",
            "        return f(ra, rb);",
            "    }",
            "    /*    void modify(int l, int r, int value) {// if update is l to r",
            "  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {",
            "    if (l&1) s[l++] += value;",
            "    if (r&1) s[--r] += value;",
            "  }",
            "}",
            "",
            "T query(int p) {// if query is about one pos",
            "  int res = 0;",
            "  for (p += n; p > 0; p >>= 1) res += s[p];",
            "  return res;",
            "}*/",
            "};",
            "ll ipowM(ll base ,ll exp,ll MOD){",
            "    ll res = 1;",
            "    while(exp>0){",
            "        if(exp&1) res = (res*base)%MOD;",
            "        exp>>=1;",
            "        base = (base*base)%MOD;",
            "    }",
            "return res;",
            "}",
            "ll invM(ll num ,ll m){",
            "    return ipowM(num,m-2,m);",
            "}",
            "",
            "ll ipow(ll base ,ll exp){",
            "    ll res = 1;",
            "    while(exp>0){",
            "        if(exp&1) res = (res*base);",
            "        exp>>=1;",
            "        base = (base*base);",
            "    }",
            "return res;",
            "}",
            "const long long int x = 100 ;",
            "ll fact[x+1];",
            "",
            "void prefact(ll MOD){",
            "    fact[0]=1;",
            "    for(int i = 1 ;i<=x ;i++){",
            "        (fact[i] = fact[i-1]*i)%MOD;",
            "    }",
            "}",
            "",
            "const int MAXN = 100;",
            "vector <int> prime;",
            " bool is_composite[MAXN];",
            "",
            "void sieve (int n) {",
            "    fill (is_composite, is_composite + n, false);",
            "     for (int i = 2; i < n; ++i) {",
            "    if (!is_composite[i]) prime.push_back (i);",
            "         for (int j = 0; j < (int)prime.size () && i * prime[j] < n; ++j) {",
            "             is_composite[i * prime[j]] = true;",
            "             if (i % prime[j] == 0) break;",
            "         }",
            "     }",
            " }",
            " //complete this function for factor related stuff",
            "void sieve2(ll n){",
            "   for(int i = 2 ;i<=n ;i++){",
            "    for(int j = 2*i ;j<=n ;j+=i)//if not factor related stuff than start it i*i",
            ";",
            "   }",
            "",
            "}",
            "ll stoii(string s){",
            "    ll ans = 0;",
            "    for(auto it: s){",
            "        ll cur = it-'0';",
            "        ans = ans*10+cur;",
            "    }",
            "    return ans;",
            "}",
            "",
            "int dx[]={-1,0,1,0};",
            "int dy[]={0,1,0,-1};",
            "bool test = true;",
            "void solve(){",
            "",
            "}",
            "int main(){",
            "    file_io();",
            "    //sieve(MAXN);",
            "    //prefact(MOD2);",
            "    //SegTree<int> s;",
            "    //FenwickTree<int> f;",
            "    int t ;",
            "    t = 1 ;",
            "    if(test)",
            "    cin>>t;",
            "    while(t--){",
            "            solve();",
            "",
            "    }",
            "    Time",
            "}"
        ],
        "description": "me"
    },
    "meetinmiddle": {
        "prefix": "meetinmiddle",
        "body": [
            "#include<bits/stdc++.h>",
            "// using namespace std;",
            "// #define vl vector<ll>",
            "// #define mii map<int,int>",
            "// #define uii unordered_map<int,int>",
            "// #define all(x) x.begin(),x.end()",
            "// #define fr(a,b) for(int i = a ; i<b ;i++)",
            "// #define ff first",
            "// #define ss second",
            "// #define ull unsigned long long int",
            "// #define ll long long",
            "// #define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);",
            "// #define endl \"\\n\"",
            "// #define INF 1e18",
            "// #define Time cerr<<\"\\nTime Taken : \"<<(float)(clock()-time_p)/CLOCKS_PER_SEC<<\"\\n\";",
            "// clock_t time_p=clock();",
            "// const long long int MOD = 1e9+7;",
            "// int main(){",
            "//     fast_io",
            "//     #ifndef ONLINE_JUDGE",
            "//     freopen(\"inputa.txt\",\"r\",stdin);",
            "//     freopen(\"outputa.txt\",\"w\",stdout);",
            "//     freopen(\"log.txt\",\"w\",stderr);",
            "//     #endif",
            "//       //meet in middle technique",
            "//      // is used when brute is not applied then we use this technique",
            "//      // algo",
            "//      // (1) split set into two subsets",
            "//      //(2) find all possible subsets sum of given set say X and for other say Y",
            "//      //(3) if we check naively then our complexity still is O(2^(n/2)*(2^(n/2)) that is same as brute :(",
            "//      //   so what we do is sort one of the X or Y and binary search for the value.",
            "//      //   this reduce are complexity O(2^(n/2)*log(2^(n/2))) which is roughly O(2^(n/2)*n) which will work for n == 40",
            "// //(Q) find maximum sum subset smaller than some element X",
            "// int n;",
            "// cin>>n;",
            "// ll x;",
            "",
            "// vector<ll> v(n);",
            "// for(ll i  = 0 ; i<n ;i ++){",
            "//     cin>>v[i];",
            "// }",
            "// cin>>x;",
            "// ll tota = 1LL<<(n/2LL);",
            "// ll totb = 1LL<<(n-n/2LL);",
            "// vector<ll> a;//subset sum for 1st half",
            "// vector<ll> b;//subset sum for 2nd half",
            "// for(ll i = 0 ; i<tota ;i++){",
            "//     ll sum = 0 ;",
            "//     for(ll j = 0 ; j<n/2 ; j++){",
            "//         //cout<<v[j]<<\" \";",
            "//        if(i&(1LL<<j))",
            "//         sum+=v[j];",
            "//     }",
            "//     //cout<<endl;",
            "//     a.push_back(sum);",
            "// }",
            "// for(ll i = 0 ; i<totb ;i++){",
            "//     ll sum = 0 ;",
            "//     for(ll j = 0; j<(n-n/2) ; j++){",
            "//        if(i&(1LL<<j))",
            "//         sum+=v[j+n/2];",
            "//     }",
            "//     b.push_back(sum);",
            "// }",
            "// sort(b.begin(),b.end());//sorting for binary_searching",
            "// ll ans  = -1 ;",
            "// //cout<<a.size()<<\" \"<<b.size()<<endl;",
            "// for(ll i = 0 ; i<a.size();i++){",
            "//     //cout<<a[i]<<\" \";",
            "//     ll ele = a[i];",
            "//     if(ele>x)",
            "//         continue;",
            "//    ll fi = x - ele;",
            "//    auto itr = lower_bound(b.begin(),b.end(),fi);",
            "//    if(itr==b.end() ||(*itr)!=fi )",
            "//     itr--;",
            "//      ans = max(ans,ele+(*itr));",
            "//      //cout<<ans<<\" \";",
            "",
            "// }",
            "// cout<<ans<<endl;",
            "// }"
        ],
        "description": "meetinmiddle"
    },
    "Mo": {
        "prefix": "Mo",
        "body": [
            "void remove(idx);  // TODO: remove value at idx from data structure",
            "void add(idx);     // TODO: add value at idx from data structure",
            "int get_answer();  // TODO: extract the current answer of the data structure",
            "",
            "int block_size;",
            "/*bool cmp(pair<int, int> p, pair<int, int> q) {",
            "    if (p.first / BLOCK_SIZE != q.first / BLOCK_SIZE)",
            "        return p < q;",
            "    return (p.first / BLOCK_SIZE & 1) ? (p.second < q.second) : (p.second > q.second);",
            "}*/",
            "struct Query {",
            "    int l, r, idx;",
            "    bool operator<(Query other) const",
            "    {",
            "        return make_pair(l / block_size, r) <",
            "               make_pair(other.l / block_size, other.r);",
            "    }",
            "};",
            "",
            "vector<int> mo_s_algorithm(vector<Query> queries) {",
            "    vector<int> answers(queries.size());",
            "    sort(queries.begin(), queries.end());",
            "",
            "    // TODO: initialize data structure",
            "",
            "    int cur_l = 0;",
            "    int cur_r = -1;",
            "    // invariant: data structure will always reflect the range [cur_l, cur_r]",
            "    for (Query q : queries) {",
            "        while (cur_l > q.l) {",
            "            cur_l--;",
            "            add(cur_l);",
            "        }",
            "        while (cur_r < q.r) {",
            "            cur_r++;",
            "            add(cur_r);",
            "        }",
            "        while (cur_l < q.l) {",
            "            remove(cur_l);",
            "            cur_l++;",
            "        }",
            "        while (cur_r > q.r) {",
            "            remove(cur_r);",
            "            cur_r--;",
            "        }",
            "        answers[q.idx] = get_answer();",
            "    }",
            "    return answers;",
            "}"
        ],
        "description": "Mo"
    },
    "modint": {
        "prefix": "modint",
        "body": [
            "constexpr int P = 998244353;",
            "using i64 = long long;",
            "// assume -P <= x < 2P",
            "int norm(int x) {",
            "    if (x < 0) {",
            "        x += P;",
            "    }",
            "    if (x >= P) {",
            "        x -= P;",
            "    }",
            "    return x;",
            "}",
            "template<class T>",
            "T power(T a, i64 b) {",
            "    T res = 1;",
            "    for (; b; b /= 2, a *= a) {",
            "        if (b % 2) {",
            "            res *= a;",
            "        }",
            "    }",
            "    return res;",
            "}",
            "struct Z {",
            "    int x;",
            "    Z(int x = 0) : x(norm(x)) {}",
            "    Z(i64 x) : x(norm(x % P)) {}",
            "    int val() const {",
            "        return x;",
            "    }",
            "    Z operator-() const {",
            "        return Z(norm(P - x));",
            "    }",
            "    Z inv() const {",
            "        assert(x != 0);",
            "        return power(*this, P - 2);",
            "    }",
            "    Z &operator*=(const Z &rhs) {",
            "        x = i64(x) * rhs.x % P;",
            "        return *this;",
            "    }",
            "    Z &operator+=(const Z &rhs) {",
            "        x = norm(x + rhs.x);",
            "        return *this;",
            "    }",
            "    Z &operator-=(const Z &rhs) {",
            "        x = norm(x - rhs.x);",
            "        return *this;",
            "    }",
            "    Z &operator/=(const Z &rhs) {",
            "        return *this *= rhs.inv();",
            "    }",
            "    friend Z operator*(const Z &lhs, const Z &rhs) {",
            "        Z res = lhs;",
            "        res *= rhs;",
            "        return res;",
            "    }",
            "    friend Z operator+(const Z &lhs, const Z &rhs) {",
            "        Z res = lhs;",
            "        res += rhs;",
            "        return res;",
            "    }",
            "    friend Z operator-(const Z &lhs, const Z &rhs) {",
            "        Z res = lhs;",
            "        res -= rhs;",
            "        return res;",
            "    }",
            "    friend Z operator/(const Z &lhs, const Z &rhs) {",
            "        Z res = lhs;",
            "        res /= rhs;",
            "        return res;",
            "    }",
            "    friend std::istream &operator>>(std::istream &is, Z &a) {",
            "        i64 v;",
            "        is >> v;",
            "        a = Z(v);",
            "        return is;",
            "    }",
            "    friend std::ostream &operator<<(std::ostream &os, const Z &a) {",
            "        return os << a.val();",
            "    }",
            "};"
        ],
        "description": "modint"
    },
    "move": {
        "prefix": "move",
        "body": [
            "// ll dx[]={0,1,0,-1};",
            "// ll dy[]={1,0,-1,0};",
            "// ll dxx[]={0,1,0,-1,1,1,-1,-1};",
            "// ll dyy[]={1,0,-1,0,1,-1,1,-1};"
        ],
        "description": "move"
    },
    "mxv": {
        "prefix": "mxv",
        "body": [
            "int mxv=*max_element(all(${1:v}));"
        ],
        "description": "print YES"
    },
    "nin": {
        "prefix": "nin",
        "body": [
            "int n;",
            "cin>>n;",
            "vector<int> v;",
            "for(int i=0;i<n;i++){",
            "\tint xx;",
            "\tcin>>xx;",
            "\tv.push_back(xx);",
            "}"
        ],
        "description": "Create an if statement to check if f == 1 and print YES/NO"
    },
    "nmin": {
        "prefix": "nmin",
        "body": [
            "int n,m;",
            "cin>>n>>m;",
            "vector<int> v;",
            "for(int i=0;i<n;i++){",
            "\tint xx;",
            "\tcin>>xx;",
            "\tv.push_back(xx);",
            "}"
        ],
        "description": "Two variable Input"
    },
    "no": {
        "prefix": "no",
        "body": [
            "cout<<\"NO\"<<\"\\n\";"
        ],
        "description": "print YES"
    },
    "pbds": {
        "prefix": "pbds",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp> ",
            "#include <ext/pb_ds/tree_policy.hpp> ",
            "using namespace __gnu_pbds; ",
            "#define ordered_set tree<int, null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>"
        ],
        "description": "Create an if statement to check if f == 1 and print YES/NO"
    },
    "phi": {
        "prefix": "phi",
        "body": [
            "/*etf : euler totient function ",
            "phi(x) : no. of numbers , in the range [0,..., x-1] that are coprime to x. ",
            "phi(p), where p is prime ,is equal to p-1//pretty obvious",
            "phi(p^k)  = p^k - p^(k-1)// not so obvious XD ",
            "explaination : ",
            "p^k coprime numbers are all numbers - multiple of p ;",
            "= p^k - (total)/p = p^k - p^(k-1)",
            "phi(m*n)  = phi(m)*phi(n) :: if m and n are coprime",
            "phi(n) = ??",
            "let say n = p1^(a1)*p2^(a2)*(p3)^(a3)......",
            "so phi(n) = (p1^a1 - p1^(a1-1))*(p2^a2 - p2^(a2-1)*........)",
            "simply ",
            "phi(n) = n*(product(1- 1/(pi)))",
            "*/",
            "ll phi(ll n){",
            "    ll ans =  n;  ",
            "    for(ll i = 2 ; i*i<=n ;i++){",
            "        if(n%i == 0 ){",
            "            while(n%i==0)",
            "                n/=i;",
            "            ans -= (ans/i);",
            "        }",
            "    }",
            "    if(n>1)",
            "        ans-=(ans/n);",
            "    return ans;",
            "}"
        ],
        "description": "phi"
    },
    "pre": {
        "prefix": "pre",
        "body": [
            "vector<long long> pre(n+2);",
            "for(int i=0;i<n;i++){",
            "    if(!i){",
            "    pre[i]=v[i];",
            "    }else{",
            "    pre[i]=pre[i-1]+v[i];",
            "    }",
            "}"
        ],
        "description": "Create an if statement to check if f == 1 and print YES/NO"
    },
    "rng": {
        "prefix": "rng",
        "body": [
            "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "int randint(int L, int R) {",
            "   uniform_int_distribution<int> dist(L, R);",
            "   return dist(rng);",
            "}"
        ],
        "description": "Random number generator"
    },
    "seg": {
        "prefix": "seg",
        "body": [
            "const int N = 4e6 + 9;",
            "",
            "int sum;",
            "",
            "struct ST {",
            "    int t[4 * N];",
            "",
            "    ST() { memset(t, 0, sizeof t); }",
            "",
            "    void build(int n, int b, int e) {",
            "        if (b == e) {",
            "            t[n] = 1;",
            "            return;",
            "        }",
            "        int mid = (b + e) >> 1, l = n << 1, r = l | 1;",
            "        build(l, b, mid);",
            "        build(r, mid + 1, e);",
            "        t[n] = t[l] + t[r];",
            "    }",
            "",
            "    void upd(int n, int b, int e, int i, int x) {",
            "        if (b > i || e < i) return;",
            "        if (b == e && b == i) {",
            "            t[n] = 0;",
            "            return;",
            "        }",
            "        int mid = (b + e) >> 1, l = n << 1, r = l | 1;",
            "        upd(l, b, mid, i, x);",
            "        upd(r, mid + 1, e, i, x);",
            "        t[n] = t[l] + t[r];",
            "    }",
            "",
            "",
            "    int query(int n, int l, int r) {",
            "        if (l == r) {",
            "            sum -= t[n];",
            "            return (sum == 0) ? r : INT_MAX;",
            "        }",
            "        if (sum > t[n]) {",
            "            sum -= t[n];",
            "            return (sum == 0) ? r : INT_MAX;",
            "        }",
            "        int mid = (l + r) >> 1;",
            "",
            "        int s1 = query(n << 1, l, mid);",
            "        if (sum == 0)",
            "            return s1;",
            "        if (sum) {",
            "            s1 = query((n << 1) | 1, mid + 1, r);",
            "        }",
            "        if (sum == 0)",
            "            return s1;",
            "        return (sum == 0) ? r : INT_MAX;",
            "    }",
            "};",
            "",
            "ST st;",
            "void solve() {",
            "    int n;",
            "    cin >> n;",
            "    st.build(1, 1, n);",
            "    vector<int> a(n / 2), b(n / 2), ans1, ans2;",
            "    cin >> a;",
            "    cin >> b;",
            "    for (int i = 0; i < n / 2; i++) {",
            "        sum = a[i];",
            "        ans1.push_back(st.query(1, 1, n));",
            "        st.upd(1, 1, n, ans1.back(), 0);",
            "        sum = b[i];",
            "        ans2.push_back(st.query(1, 1, n));",
            "        st.upd(1, 1, n, ans2.back(), 0);",
            "    }",
            "    cout << ans1 << \"\\n\";",
            "    cout << ans2 << \"\\n\";",
            "}"
        ],
        "description": "seg"
    },
    "shash": {
        "prefix": "shash",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "#ifdef Sabbir",
            "#include <E:\\CodeBox\\TempBox\\Debug\\debug.h>",
            "#include <E:\\CodeBox\\TempBox\\Basic\\db.h>",
            "#else",
            "#define dbg(x...)",
            "#endif",
            "#define ll                 long long",
            "#define all(x)             (x).begin(), (x).end()",
            "#define rev(x)             reverse(all(x))",
            "#define in(v)              for(auto &b:v)cin>>b;",
            "#define pb                 push_back",
            "#define vi                 vector<int> ",
            "const int mx=4e5+5;",
            "// #warning CHANGE INT-LONG-LONG IN CASE OF ORDERED SET",
            "// #warning CHANGE MAX VALUE",
            "// #warning change endl and FastIO for interactive",
            "typedef long long LL;",
            "typedef long double LD;",
            "#define pi acos(-1)",
            "#define int long long",
            "#define pii pair<int,int>",
            "const LL MAX = 100;",
            "const LL MOD = (1e9) + 7;",
            "const LL INF = (1e15) + 5;",
            "typedef pair<LL, LL> PLL;",
            "",
            "namespace Hashing {",
            "    #define ff first",
            "    #define ss second",
            "",
            "    // Large prime numbers for modulo operations",
            "    const PLL M = {1e9+7, 1e9+9}; ",
            "",
            "    // Base for the hash functions, should be larger than alphabet size",
            "    const LL base = 1259;",
            "",
            "    // Highest length of string to be hashed",
            "    const int N = 1e6+7; ",
            "",
            "    // Operator overloading for PLL struct to simplify arithmetic operations",
            "    PLL operator+ (const PLL& a, LL x)     {return {a.ff + x, a.ss + x};}",
            "    PLL operator- (const PLL& a, LL x)     {return {a.ff - x, a.ss - x};}",
            "    PLL operator* (const PLL& a, LL x)     {return {a.ff * x, a.ss * x};}",
            "    PLL operator+ (const PLL& a, PLL x)    {return {a.ff + x.ff, a.ss + x.ss};}",
            "    PLL operator- (const PLL& a, PLL x)    {return {a.ff - x.ff, a.ss - x.ss};}",
            "    PLL operator* (const PLL& a, PLL x)    {return {a.ff * x.ff, a.ss * x.ss};}",
            "    PLL operator% (const PLL& a, PLL m)    {return {a.ff % m.ff, a.ss % m.ss};}",
            "    ostream& operator<<(ostream& os, PLL hash) {",
            "        return os<<\"(\"<<hash.ff<<\", \"<<hash.ss<<\")\";",
            "    }",
            "",
            "    // Array to store powers of the base mod M",
            "    PLL pb[N];      ",
            "",
            "    // Precomputes the powers of the base modulo M",
            "    void hashPre() {",
            "        pb[0] = {1,1};",
            "        for (int i=1; i<N; i++) pb[i] = (pb[i-1] * base)%M;",
            "    }",
            "",
            "    // Calculates the hashes of all prefixes of a string, including the empty prefix",
            "    vector<PLL> hashList(string s) {",
            "        int n = s.size();",
            "        vector<PLL> ans(n+1);",
            "        ans[0] = {0,0};",
            "        for (int i=1; i<=n; i++) ans[i] = (ans[i-1] * base + s[i-1])%M;",
            "        return ans;",
            "    }",
            "",
            "    // Calculates the hash of a substring s[l..r] (1-indexed)",
            "    PLL substringHash(const vector<PLL> &hashlist, int l, int r) {",
            "        return (hashlist[r]+(M-hashlist[l-1])*pb[r-l+1])%M;",
            "    }",
            "",
            "    // Calculates the hash of a whole string",
            "    PLL Hash (string s) {",
            "        PLL ans = {0,0};",
            "        for (int i=0; i<s.size(); i++)  ans=(ans*base + s[i])%M;",
            "        return ans;",
            "    }",
            "",
            "    // Appends a character to the current hash and updates it",
            "    PLL append(PLL cur, char c) {",
            "        return (cur*base + c)%M;",
            "    }",
            "",
            "    // Prepends a character to the current hash with size k",
            "    PLL prepend(PLL cur, int k, char c) {",
            "        return (pb[k]*c + cur)%M;",
            "    }",
            "",
            "    // Replaces the i-th (0-indexed) character from right in the hash from 'a' to 'b'",
            "    PLL replace(PLL cur, int i, char a, char b) {",
            "        return cur + pb[i] * (M+b-a)%M;",
            "    }",
            "",
            "    // Erases a character from the front of the string with size len",
            "    PLL pop_front(PLL hash, int len, char c) {",
            "        return (hash + pb[len-1]*(M-c))%M;",
            "    }",
            "",
            "    // Concatenates two hashes where the length of the right is k",
            "    PLL concat(PLL left, PLL right, int k) {",
            "        return (left*pb[k] + right)%M;",
            "    }",
            "",
            "    // Computes the power of a hash value using modular exponentiation",
            "    PLL power (const PLL& a, LL p) {",
            "        if (p==0)   return {1,1};",
            "        PLL ans = power(a, p/2);",
            "        ans = (ans * ans)%M;",
            "        if (p%2)    ans = (ans*a)%M;",
            "        return ans;",
            "    }",
            "",
            "    // Computes the modular inverse of a hash value",
            "    PLL inverse(PLL a)  {",
            "        if (M.ss == 1)  return power(a, M.ff-2);",
            "        return power(a, (M.ff-1)*(M.ss-1)-1);",
            "    }",
            "",
            "    // Erases a character from the back of the string",
            "    PLL invb = inverse({base, base});",
            "    PLL pop_back(PLL hash, char c) {",
            "        return ((hash-c+M)*invb)%M;",
            "    }",
            "",
            "    // Calculates the hash of a string with size len repeated cnt times",
            "    PLL repeat(PLL hash, int len, LL cnt) {",
            "        PLL mul = ((pb[len*cnt]-1+M) * inverse(pb[len]-1+M))%M;",
            "        PLL ans = (hash*mul);",
            "        if (pb[len].ff == 1)    ans.ff = hash.ff*cnt;",
            "        if (pb[len].ss == 1)    ans.ss = hash.ss*cnt;",
            "        return ans%M;",
            "    }",
            "}",
            "",
            "int pagol()",
            "{",
            "    int n, k;",
            "    cin >> n >> k;",
            "    string inp, a, b, rev;",
            "    cin >> inp;",
            "    rev = inp;",
            "    reverse(all(rev));",
            "",
            "    // Build strings a and b with alternating 0s and 1s",
            "    for(int i = 0, parity = 0 ; i < n ; i+=k, parity++) ",
            "    {",
            "        for(int j = i ; j < i+k ; j++)",
            "        {",
            "            a.push_back('0' + (parity%2 == 0));",
            "            b.push_back('0' + (parity%2 == 1));",
            "        }",
            "    }",
            "",
            "    // Calculate hashes for a and b",
            "    pii hash1 = Hashing::Hash(a), hash2 = Hashing::Hash(b);",
            "    vector <pii> hL = Hashing::hashList(inp), rL = Hashing::hashList(rev);",
            "",
            "    // Check if any rotation of the string can match hash1 or hash2",
            "    for(int i = 0 ; i < n ; i++)",
            "    {",
            "        int indx = i+1;",
            "        pii opHash = Hashing::concat(Hashing::substringHash(hL, indx+1, n), Hashing::substringHash(rL, n-indx+1, n), indx);",
            "        if(opHash == hash1 || opHash == hash2)",
            "        {",
            "            cout << indx << endl;",
            "            return 0;",
            "        }",
            "    }",
            "    cout << -1 << endl;",
            "    return 0;",
            "}",
            "",
            "int32_t main() {",
            "  ios::sync_with_stdio(0);cin.tie(0);",
            "  #ifdef Sabbir",
            "      freopen(\"Error.txt\", \"w\", stderr);",
            "  #endif",
            "  Hashing::hashPre();",
            "  int t = 1;",
            "  cin>>t;",
            "  while (t--) {",
            "    pagol();",
            "  }",
            "  return 0;",
            "}"
        ],
        "description": "shash"
    },
    "shash2": {
        "prefix": "shash2",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "#ifdef Sabbir",
            "#include <E:\\CodeBox\\TempBox\\Debug\\debug.h>",
            "#include <E:\\CodeBox\\TempBox\\Basic\\db.h>",
            "#else",
            "#define dbg(x...)",
            "#endif",
            "#define ll                 long long",
            "#define all(x)             (x).begin(), (x).end()",
            "#define rev(x)             reverse(all(x))",
            "#define in(v)              for(auto &b:v)cin>>b;",
            "#define pb                 push_back",
            "#define vi                 vector<int> ",
            "const int mx=4e5+5;",
            "// #warning CHANGE INT-LONG-LONG IN CASE OF ORDERED SET",
            "// #warning CHANGE MAX VALUE",
            "// #warning change endl and FastIO for interactive",
            "typedef long long LL;",
            "typedef long double LD;",
            "#define pi acos(-1)",
            "#define int long long",
            "#define pii pair<int,int>",
            "const LL MAX = 100;",
            "const LL MOD = (1e9) + 7;",
            "const LL INF = (1e15) + 5;",
            "typedef pair<LL, LL> PLL;",
            "",
            "namespace Hashing {",
            "    #define ff first",
            "    #define ss second",
            "",
            "    // Large prime numbers for modulo operations",
            "    const PLL M = {1e9+7, 1e9+9}; ",
            "",
            "    // Base for the hash functions, should be larger than alphabet size",
            "    const LL base = 1259;",
            "",
            "    // Highest length of string to be hashed",
            "    const int N = 1e6+7; ",
            "",
            "    // Operator overloading for PLL struct to simplify arithmetic operations",
            "    PLL operator+ (const PLL& a, LL x)     {return {a.ff + x, a.ss + x};}",
            "    PLL operator- (const PLL& a, LL x)     {return {a.ff - x, a.ss - x};}",
            "    PLL operator* (const PLL& a, LL x)     {return {a.ff * x, a.ss * x};}",
            "    PLL operator+ (const PLL& a, PLL x)    {return {a.ff + x.ff, a.ss + x.ss};}",
            "    PLL operator- (const PLL& a, PLL x)    {return {a.ff - x.ff, a.ss - x.ss};}",
            "    PLL operator* (const PLL& a, PLL x)    {return {a.ff * x.ff, a.ss * x.ss};}",
            "    PLL operator% (const PLL& a, PLL m)    {return {a.ff % m.ff, a.ss % m.ss};}",
            "    ostream& operator<<(ostream& os, PLL hash) {",
            "        return os<<\"(\"<<hash.ff<<\", \"<<hash.ss<<\")\";",
            "    }",
            "",
            "    // Array to store powers of the base mod M",
            "    PLL pb[N];      ",
            "",
            "    // Precomputes the powers of the base modulo M",
            "    void hashPre() {",
            "        pb[0] = {1,1};",
            "        for (int i=1; i<N; i++) pb[i] = (pb[i-1] * base)%M;",
            "    }",
            "",
            "    // Calculates the hashes of all prefixes of a string, including the empty prefix",
            "    vector<PLL> hashList(string s) {",
            "        int n = s.size();",
            "        vector<PLL> ans(n+1);",
            "        ans[0] = {0,0};",
            "        for (int i=1; i<=n; i++) ans[i] = (ans[i-1] * base + s[i-1])%M;",
            "        return ans;",
            "    }",
            "",
            "    // Calculates the hash of a substring s[l..r] (1-indexed)",
            "    PLL substringHash(const vector<PLL> &hashlist, int l, int r) {",
            "        return (hashlist[r]+(M-hashlist[l-1])*pb[r-l+1])%M;",
            "    }",
            "",
            "    // Calculates the hash of a whole string",
            "    PLL Hash (string s) {",
            "        PLL ans = {0,0};",
            "        for (int i=0; i<s.size(); i++)  ans=(ans*base + s[i])%M;",
            "        return ans;",
            "    }",
            "",
            "    // Appends a character to the current hash and updates it",
            "    PLL append(PLL cur, char c) {",
            "        return (cur*base + c)%M;",
            "    }",
            "",
            "    // Prepends a character to the current hash with size k",
            "    PLL prepend(PLL cur, int k, char c) {",
            "        return (pb[k]*c + cur)%M;",
            "    }",
            "",
            "    // Replaces the i-th (0-indexed) character from right in the hash from 'a' to 'b'",
            "    PLL replace(PLL cur, int i, char a, char b) {",
            "        return cur + pb[i] * (M+b-a)%M;",
            "    }",
            "",
            "    // Erases a character from the front of the string with size len",
            "    PLL pop_front(PLL hash, int len, char c) {",
            "        return (hash + pb[len-1]*(M-c))%M;",
            "    }",
            "",
            "    // Concatenates two hashes where the length of the right is k",
            "    PLL concat(PLL left, PLL right, int k) {",
            "        return (left*pb[k] + right)%M;",
            "    }",
            "",
            "    // Computes the power of a hash value using modular exponentiation",
            "    PLL power (const PLL& a, LL p) {",
            "        if (p==0)   return {1,1};",
            "        PLL ans = power(a, p/2);",
            "        ans = (ans * ans)%M;",
            "        if (p%2)    ans = (ans*a)%M;",
            "        return ans;",
            "    }",
            "",
            "    // Computes the modular inverse of a hash value",
            "    PLL inverse(PLL a)  {",
            "        if (M.ss == 1)  return power(a, M.ff-2);",
            "        return power(a, (M.ff-1)*(M.ss-1)-1);",
            "    }",
            "",
            "    // Erases a character from the back of the string",
            "    PLL invb = inverse({base, base});",
            "    PLL pop_back(PLL hash, char c) {",
            "        return ((hash-c+M)*invb)%M;",
            "    }",
            "",
            "    // Calculates the hash of a string with size len repeated cnt times",
            "    PLL repeat(PLL hash, int len, LL cnt) {",
            "        PLL mul = ((pb[len*cnt]-1+M) * inverse(pb[len]-1+M))%M;",
            "        PLL ans = (hash*mul);",
            "        if (pb[len].ff == 1)    ans.ff = hash.ff*cnt;",
            "        if (pb[len].ss == 1)    ans.ss = hash.ss*cnt;",
            "        return ans%M;",
            "    }",
            "}",
            "",
            "int pagol()",
            "{",
            "    int n, k;",
            "    cin >> n >> k;",
            "    string inp, a, b, rev;",
            "    cin >> inp;",
            "    rev = inp;",
            "    reverse(all(rev));",
            "",
            "    // Build strings a and b with alternating 0s and 1s",
            "    for(int i = 0, parity = 0 ; i < n ; i+=k, parity++) ",
            "    {",
            "        for(int j = i ; j < i+k ; j++)",
            "        {",
            "            a.push_back('0' + (parity%2 == 0));",
            "            b.push_back('0' + (parity%2 == 1));",
            "        }",
            "    }",
            "",
            "    // Calculate hashes for a and b",
            "    pii hash1 = Hashing::Hash(a), hash2 = Hashing::Hash(b);",
            "    vector <pii> hL = Hashing::hashList(inp), rL = Hashing::hashList(rev);",
            "",
            "    // Check if any rotation of the string can match hash1 or hash2",
            "    for(int i = 0 ; i < n ; i++)",
            "    {",
            "        int indx = i+1;",
            "        pii opHash = Hashing::concat(Hashing::substringHash(hL, indx+1, n), Hashing::substringHash(rL, n-indx+1, n), indx);",
            "        if(opHash == hash1 || opHash == hash2)",
            "        {",
            "            cout << indx << endl;",
            "            return 0;",
            "        }",
            "    }",
            "    cout << -1 << endl;",
            "    return 0;",
            "}",
            "",
            "int32_t main() {",
            "  ios::sync_with_stdio(0);cin.tie(0);",
            "  #ifdef Sabbir",
            "      freopen(\"Error.txt\", \"w\", stderr);",
            "  #endif",
            "  Hashing::hashPre();",
            "  int t = 1;",
            "  cin>>t;",
            "  while (t--) {",
            "    pagol();",
            "  }",
            "  return 0;",
            "}"
        ],
        "description": "shash2"
    },
    "sieve": {
        "prefix": "sieve",
        "body": [
            "vector<int> primes;",
            "const ll mx = 1e6+1;",
            "vector<bool>  isprime(mx,true);",
            "void sieve(){",
            "isprime[1] = false;",
            "for(ll i = 2 ;i*i<=mx ;i++){",
            "    if(isprime[i]){",
            "   //primes.pb(i);",
            "    for(ll j = i*i ;j<=mx;j+=i){",
            "        isprime[j] = false;",
            "",
            "    }",
            "}",
            "}",
            "for(int i = 2 ;i<=x ;i++){",
            "    if(isprime[i])",
            "    primes.pb(i);",
            "   }",
            "}"
        ],
        "description": "sieve"
    },
    "sin": {
        "prefix": "sin",
        "body": [
            "int n;",
            "cin>>n;",
            "string s;",
            "cin>>s;",
            "int ans=0;",
            "for(int i=0;i<n;i++){",
            "    if(s[i]-'0'==1){",
            "       ans++;",
            "    }",
            "}"
        ],
        "description": "Create an if statement to check if f == 1 and print YES/NO"
    },
    "sparse": {
        "prefix": "sparse",
        "body": [
            "//define it as  ",
            "// sparse_table<ll> st(d, n, [] (ll x, ll y) ",
            "//     {",
            "//         return __gcd(x, y);",
            "//     });",
            "//where d is your vector on which you want to build sparse ",
            "//__gcd is any binary function",
            "// https://codeforces.com/blog/entry/",
            "template<typename T>",
            "struct sparse_table ",
            "{",
            "    using F = function<T(const T&, const T&)>;",
            " ",
            "    int n;",
            "    vector<vector<T>> mat;",
            "    F f;",
            "    sparse_table() : n(), f() {}",
            " ",
            "    template<typename U>",
            "    sparse_table(const U& arr, int n, F f): n(n), f(f), mat((int) log2(n) + 1) ",
            "    {",
            "        mat[0].resize(n);",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            mat[0][i] = T(arr[i]);",
            "        }",
            "        for (int j = 1; j < int(mat.size()); j++) {",
            " ",
            "            mat[j].resize(n - (1 << j) + 1);",
            "            for (int i = 0; i + (1 << j) <= n; i++) ",
            "            {",
            "                mat[j][i] = f(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);",
            "            }",
            "        }",
            "    }",
            " ",
            "    T query(int l, int r) //[ 0 .. n-1]",
            "    {",
            "        int j = 32 - __builtin_clz(r - l + 1) - 1;",
            "        return f(mat[j][l], mat[j][r + 1 - (1 << j)]);",
            "    }",
            "};"
        ],
        "description": "sparse"
    },
    "temp": {
        "prefix": "temp",
        "body": [
            "#include<bits/stdc++.h>",
            "#ifdef Sabbir",
            "#pragma GCC diagnostic ignored \"-Wunused-variable\"",
            "#pragma GCC diagnostic ignored \"-Wsign-compare\"",
            "#endif",
            "using namespace std;",
            "#ifdef Sabbir",
            "#include <E:\\CodeBox\\TempBox\\Debug\\debug.h>",
            "#else",
            "#define dbg(x...)",
            "#endif",
            "#define ll                 long long",
            "#define all(x)             (x).begin(), (x).end()",
            "#define in(v)               for(auto &b:v)cin>>b;",
            "#define pb                  push_back",
            "#define inf               (long long)1e8+7",
            "const int mx=4e5+5;",
            "",
            "void pagol(){",
            " ",
            " ",
            "}",
            "",
            "int32_t main() {",
            "  ios::sync_with_stdio(0);cin.tie(0);",
            "  #ifdef Sabbir",
            "      freopen(\"Error.txt\", \"w\", stderr);",
            "  #endif",
            "    int t = 1;",
            "    cin>>t;",
            "    while (t--) {",
            "",
            "        pagol();",
            "    }",
            "    return 0;",
            "}",
            "//\u09af\u09a6\u09cd\u09a6\u09aa\u09c0, \u0986\u09ae\u09bf \u09a4\u09be\u09b9\u09be\u09a4\u09c7\u0987 \u09ae\u09c1\u0997\u09cd\u09a7 \u09b9\u0987\u09df\u09be \u0997\u09bf\u09df\u09be\u099b\u09bf"
        ],
        "description": "temp"
    },
    "varr": {
        "prefix": "varr",
        "body": [
            "vector<array<int,3>> va;"
        ],
        "description": ""
    },
    "yes": {
        "prefix": "yes",
        "body": [
            "cout<<\"YES\"<<\"\\n\";"
        ],
        "description": "print YES"
    },
    "zalgo": {
        "prefix": "zalgo",
        "body": [
            "// An element Z[i] of Z array stores length of the longest substring",
            "// starting from str[i] which is also a prefix of str[0..n-1].",
            "// The first entry of Z array is meaning less as complete string is always prefix of itself.",
            "// Here Z[0]=0.",
            "vector<int> z_function(string s) {",
            "  int n = (int) s.length();",
            "  vector<int> z(n);",
            "  for (int i = 1, l = 0, r = 0; i < n; ++i) {",
            "    if (i <= r)",
            "      z[i] = min (r - i + 1, z[i - l]);",
            "    while (i + z[i] < n && s[z[i]] == s[i + z[i]])",
            "      ++z[i];",
            "    if (i + z[i] - 1 > r)",
            "      l = i, r = i + z[i] - 1;",
            "  }",
            "  return z;",
            "}"
        ],
        "description": "zalgo"
    }
}